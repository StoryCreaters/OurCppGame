# 项目文档

## 游戏名称：泡泡堂

## 组队分工

mapleFU(1652728): 项目架构，游戏逻辑

chris0king(1652769) : UI\图片制作

zhongyuchen() : 网络连接

## 游戏玩法

* 进入时，可以选择help进行帮助，也可以在setting里面调整音量、音效
* 选择start, 输入你的玩家名可以开始游戏
* 在room界面，你可以选择一个房间进入，选择你想要的地图
* 在room里，你可以选择聊天 退出
* 在游戏界面，击败你所有的敌人获得胜利吧
  * 你可以按空格放置泡泡
  * 你可以上下左右移动
  * 你可以点击左侧道具使用
    * 道具：针—如果你被困住，可以使用针脱困
    * 罐头：如果你坐在骑宠上，可以无上限的增加你的骑宠速度
    * 人参果：瞬间把你的人物属性全部提到全游戏最高属性，一段时间后恢复本人物的最高属性
    * 盾牌：一定时间内放置自己被炸
  * 你可以使用骑宠
    * 骑宠被炸时，会开启一次护盾
    * 在骑宠上，以骑宠的速度为准
  * 被困住时，你除了等死... 什么都做不了了～

## 游戏平台

仅支持Windows

## 使用到的库

cocos2d-x 3.14.1

## 游戏逻辑—细节

**项目整体采取了MVC的架构**

* model —处理逻辑的模型
  * character 人物类
    * charaFSM 人物的状态机
  * Vehicle 骑宠类
  * GameItem 道具类
* Controller—与玩家交互的控制类
  * BaseController—控制类的基类，继承自层
    * PropController—玩家道具按键控制
    * BubbleController—玩家炸弹放置控制
    * PlayerController—玩家方向控制
* View— 视图展现




## 游戏逻辑部分实现细节

### 基于组合

character, GameItem和Vehicle的逻辑因为考虑到不会改变，所以用了组合的方式来处理逻辑

(**实际上，这样不适合扩展**)

以character基础属性为例

```c++
bool character::initWithPlayerType(characterType type)
{
    // 给不同的角色初始化不同属性
    // 这里只做了一个人物真是抱歉了
    // TODO: 更新人物和属性
    using namespace settings::Character;
    
    // 属性设置
    _spriteName = sprite_names[type];
    
    _maxBubbles = max_bubbles[type];
    _currentBubbles = start_bubbles[type];
    _currentPower = start_powers[type];
    _maxPower = max_powers[type];
    _currentVelocity = start_velocity[type];
    _maxVelocity = max_velocity[type];
    mCurState = std::make_shared<CharNormal>();
    _animation_frames = animation_frames[type];
    curSetBubbles = 0;
    // 记住加入png
    this->initWithSpriteFrameName("player" + std::to_string(type + 1) + "_down_01.png");
    this->initWithFile(sprite_paths[type]);
    return true;
}
```

character这样处理，也能获得一定程度的抽象

***

### 基于继承

characterFSM是基于继承来处理的，character维护一个std::shared_ptr<BaseFsm> mCurState表示它的状态

同时诸多状态类继承自BaseFsm, 利用多态针对玩家的状态来处理事件

```c++
class CharNormal : public State {
public:
    void excute(cocos2d::Sprite* spr) override;
    void PreProcess(cocos2d::Sprite* spr) override {};
};

class CharStuck : public State {
public:
    void excute(cocos2d::Sprite* spr) override;
    void PreProcess(cocos2d::Sprite* spr) override;
};

class CharDead : public State {
public:
    void excute(cocos2d::Sprite* spr) override {}
    void PreProcess(cocos2d::Sprite* spr) override;
};
```



同样的，controller也是基于继承的。这里便不贴代码了

##  使用的设计模式

### 状态模式

如上所述，使用了状态机表示人物状态

### 观察者模式

有消息则触发GameScene

## 部分缺点

1. 有的地方做的不是很面向对象(虽然我本人觉得这样挺方便的...)

```c++
cocos2d::Animation* getAnimationByName(const std::string &animName,float delay,int animNum);
void runAnimationByName(cocos2d::Sprite* spr,const std::string &animName,float delay,int animNum);
```

(摘自commonUse.h)

2. 部分实现不够完善，例如BubbleBoom的时候写的相当丑陋

```C++
void GameScene::boom_animate(cocos2d::Vec2 pos, int power, int r_vec) {
    /*
     args: pos->position of sprite, power:power of bubble, vector:direction
     */
    auto tiled_position = tileCoordForPosition(pos);
    --tiled_position.y;
    static auto std_delta = Vec2(offx, offy);
    
    // dir: 0->horizontal, 1->vertical;
    Vec2 dirs[] = {Vec2(1, 0), Vec2(0, 1)};
    // 正负方向和该方向是否停止
    int syn[] = {-1, 1};
    bool synb[] = {true, true};
    for (int i = 1; i <= power; ++i) {
        for (int j = 0; j < 2; ++j) {
            if (!synb[j])
                continue;
            // 获取下一个爆炸的位置
            auto next_p = dirs[r_vec] * syn[j] * i + tiled_position;
            removePositionItem(next_p);

            // 判断爆炸位置是否在地图中
            if (!in_map(next_p.x, next_p.y)) {
                synb[j] = false;
                continue;
            }
            // 是否扩展
            bool ans(false);
            if (check_chain_boom(next_p)) {
                // chain booming!!!
            } else if (!hasCollisionInGridPos(next_p) && !prop_gotton[next_p.x][next_p.y]) {
                // have tile
                // need delay time and broken animation
                prop_gotton[next_p.x][next_p.y] = true;
                this->runAction(Sequence::create(DelayTime::create(0.2f), CallFuncN::create(
                      [=](Ref* sender) {
                          _meta->removeTileAt(next_p);
                          if (prop_on_map[next_p.x][next_p.y] < GameItem::toolNumbers) {
                              this->addItems(next_p, static_cast<GameItem::ItemTools>(prop_on_map[next_p.x][next_p.y]));
                          }
                      }), NULL));
            } else {
                // check if someone dead
                auto new_blaze = Sprite::create(boom_anime[r_vec]);
                auto mySpritePos = _background->getPositionAt(next_p) * _tile_delta_rate + std_delta;
                for (auto &chara: _game_players) {
                    if (typeid(*(chara->mCurState)) == typeid(CharGuard)) {
                        continue;
                    }
                    if (tileCoordForPosition(chara->getPosition()) == next_p) {
                        // chara was fired
//                        log("fired");
                        chara->charaFired();
                    }
                }
                ans = true;
                add_and_clear_with_time(new_blaze, boom_time, mySpritePos);
            }
            synb[j] = ans;
        }
    }
}
```

在这里逻辑不是很清晰，可以考虑抽象出BubbleWave类来抽象并且使爆炸过程更清晰

## 用到的C++11特性

1. lambda expression
   整个项目都是这些东西...

   ```c++
   restart_button->addTouchEventListener([=](Ref* pSender, Widget::TouchEventType type) {
           if (type == Widget::TouchEventType::ENDED) {
               auto transition = TransitionFadeBL::create(2.0, GameScene::createScene());
               Director::getInstance()->replaceScene(transition);
           }
       });
   ```

   但是项目开发曾经存在过坑：由于对cocos2d-x内存管理机制不熟悉，采用[&]引用捕获的时候曾经出现bug

2. std::function
   用function进行条件判断，实现对组合的抽象

   ```c++
   std::function<void()> PropLayer::getPropfuncs(int index) {
       switch (index) {
           case 0:
               return [](){return character::getMychara()->rideSpeedUp();};
               break;
           case 1:
               return [](){return character::getMychara()->UseNeedle();};
               break;
           case 2:
               return [](){return character::getMychara()->setGuard();};
               break;
           case 3:
               return [](){return character::getMychara()->powerup();};
               break;
       }
   }

   std::function<bool()> PropLayer::getAblefuncs(int index) {
       switch (index) {
           case 0:
               return [](){return character::getMychara()->isRiding();};
               break;
           case 1:
               return [](){return character::getMychara()->isStucked();};
               break;
           case 2:
               return [](){return true;};
               break;
           case 3:
               return [](){return true;};
               break;
       }
   }
   ```

3. auto 自动类型推断
   我自己都觉得这个写的不好意思...

4. range for

   ```c++
   void PreLoadScene::loadSpriteFrame() {
   	using namespace settings::PreLoadScene;
   	// 道具动画
   	auto sprite_frame_cache = SpriteFrameCache::getInstance();
   	for (auto s : gifts_animation) {
   		sprite_frame_cache->addSpriteFramesWithFile(s);
   	}
   	for (auto s : person_animation) {
   		sprite_frame_cache->addSpriteFramesWithFile(s);
   	}
   	sprite_frame_cache->addSpriteFramesWithFile(bubbles_animation);
   }
   ```

   PreLoadScene中，这样即使增加部分函数也不需要改变

5. std::shared_ptr

   ```c++
   void character::excute() {
       this->mCurState->excute(this);
   }

   void character::changeState(std::shared_ptr<State> next_state) {
       this->mCurState = next_state;
       this->mCurState->PreProcess(this);
   }
   ```

   这样省去了清楚的麻烦

6. constexpr

   ```c++
   namespace settings {
       enum directions {
           UP, DOWN, LEFT, RIGHT, DEFAULT
       };
       
       namespace OpenScene {
           constexpr char* UiNames[] = {
               "GameUI/ProjectName",
               "GameUI/PlayMyself",
               "GameUI/PlayOnInternet",
               "GameUI/Settings",
               "GameUI/Help",
               "GameUI/Quit"
           };
           
           constexpr char* helps[] = {
               "Hi, this is a bnb game",
               "made by maplewind, Chris and shadowfox",
               "use up\\down\\left\\right to control your charactor",
               "and you can press \"help\" to get some information",
               "have fun~"
           };
       }

   ```

   setting中，让程序在编译期处理这些逻辑




## 团队合作

详见https://github.com/StoryCreaters


## 实现的功能

##### 先实现项目要求的基本功能

- 支持动画效果**(finished)**
- 支持鼠标和键盘操作交互**(finished)**
- 支持障碍物**(finished)**
- 支持泡泡的放置与爆炸**(finished)**
- 支持三种基本道具**(finished)**
  - 实现服务端，支持多人在同一地图游戏**(finished)**
- 支持地图绘制，人物绘制，水泡效果绘制**(finished)**

##### 额外功能

- 支持多个角色**(finished)**
- 支持聊天**(finished)**
- 支持房间列表**(finished)**
- 支持>=2张地图**(finished)**
- 支持>=2种游戏模式
- 支持使用道具**(finish)**
- 支持骑宠**(finish)**
- 支持用名称登陆**(finish)**


## 单元测试：无

## 平台移植：暂无

## 安全

用CCASSERT判断申请的指针是否是nullptr

```c++
ptr = dynamic_cast<>..
#ifdef DEBUG
	assert(ptr)
#endif
```

由于类的关系搞错, 这段逻辑曾经导致本人debug半晚上...


# LISENCE: MIT




